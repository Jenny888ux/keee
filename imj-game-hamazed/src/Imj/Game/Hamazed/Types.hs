{-# OPTIONS_HADDOCK hide #-}
-- | Contains types that the game server doesn't need to know about.

{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}

module Imj.Game.Hamazed.Types
    ( ProgramEnd(..)
    , Game(..)
    , GameTime
    , GameState(..)
    , UpdateEvent
    , EventGroup(..)
    , GenEvent(..)
    , initialParameters
    , initialViewMode
    , minRandomBlockSize
    -- * Reexports
    , module Imj.Game.Hamazed.Chat
    , module Imj.Game.Hamazed.Level.Types
    , module Imj.Game.Hamazed.World.Types
    , UIAnimation
    ) where

import           Imj.Prelude
import           Control.Exception.Base(Exception(..))
import           Data.Map.Strict(Map)
import           Data.Text(unpack)

import           Imj.Game.Hamazed.Level.Types
import           Imj.Game.Hamazed.Loop.Event.Types
import           Imj.Game.Hamazed.Network.Types
import           Imj.Game.Hamazed.World.Types
import           Imj.Game.Hamazed.World.Space.Types

import           Imj.Game.Hamazed.Chat
import           Imj.Game.Hamazed.Loop.Timing
import           Imj.Graphics.UI.Animation


data ProgramEnd =
    GracefulClientEnd
  | GracefulServerEnd
  | UnexpectedProgramEnd !Text
  |Â ErrorFromServer !String
instance Exception ProgramEnd
instance Show ProgramEnd where
  show GracefulClientEnd        = withNewline "Thanks for playing!"
  show GracefulServerEnd        = withNewline "Server has shut down."
  show (UnexpectedProgramEnd s) = withNewline $ unpack $ "Program ended: " <> s
  show (ErrorFromServer s)      = withNewline $ "An error occured in the Server: " ++ s

withNewline :: String -> String
withNewline = flip (++) "\n"


data EventGroup = EventGroup {
    events :: ![UpdateEvent]
  , _eventGroupHasPrincipal :: !Bool
  , _eventGroupUpdateDuration :: !(Time Duration System)
  , _eventGroupVisibleTimeRange :: !(Maybe (TimeRange System))
  -- ^ TimeRange of /visible/ events deadlines
}

-- | Regroups events that can be handled immediately by the client.
type UpdateEvent = Either ServerEvent Event

{- Regroups all kinds of events. -}
data GenEvent =
    Evt {-unpack sum-} !Event
    -- ^ Are generated by the client and can be handled by the client immediately.
  | CliEvt {-unpack sum-} !ClientEvent
    -- ^ Are generated by the client but can't be handled by the client, and are sent to the game server.
  | SrvEvt {-unpack sum-} !ServerEvent
    -- ^ Are generated by the game server, and can be handled by the client immediately once received.
    deriving(Generic, Show)

data Game = Game {
    getClientState' :: {-# UNPACK #-} !ClientState
  , getGameState' :: !GameState
  , _gameSuggestedPlayerName :: {-unpack sum-} !SuggestedPlayerName
  , getServer :: {-unpack sum-} !Server
  -- ^ The server that runs the game
  , connection' :: {-unpack sum-} !ConnectionStatus
  , getChat' :: !Chat
}

{-| 'GameState' has two fields of type 'World' : during 'Level' transitions,
we draw the /old/ 'World' while using the /new/ 'World' 's
dimensions to animate the UI accordingly. -}
data GameState = GameState {
    currentWorld :: !World
  , mayFutureWorld :: !(Maybe World)
    -- ^ Maybe the world that we transition to (when a level is over).
    -- Once the transition is over, we replace 'currentWorld' with this 'Just' value.
  , _gameStateShotNumbers :: ![ShotNumber]
    -- ^ Which 'Number's were shot
  , getGameLevel :: !Level
    -- ^ The current 'Level'
  , getUIAnimation :: !UIAnimation
    -- ^ Inter-level animation.
  , getScreen :: {-# UNPACK #-} !Screen
  , getViewMode' :: {-unpack sum-} !ViewMode
  , players :: !(Map ShipId Player)
}

minRandomBlockSize :: Int
minRandomBlockSize = 6 -- using 4 it once took a very long time (one minute, then I killed the process)
                       -- 6 has always been ok

initialParameters :: WorldParameters
initialParameters = WorldParameters Rectangle2x1 (Random defaultRandom)

initialViewMode :: ViewMode
initialViewMode = CenterSpace

defaultRandom :: RandomParameters
defaultRandom = RandomParameters minRandomBlockSize OneComponentPerShip
