{-# OPTIONS_HADDOCK hide #-}

{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
--{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Imj.Game.Hamazed.Loop.Event.Types
        ( Event(..)
        , UpdateEvent
        , EventGroup(..)
        , Deadline(..)
        , ActionTarget(..)
        , DeadlineType(..)
        , MetaAction(..)
        , ClientAction(..)
        , ClientActionResult(..)
        , ServerStepIdx(..)
        , ClientState(..)
        , ClientEvent(..)
        , ServerEvent(..)
        , GameStep(..)
        , ShipId(..)
        -- * Reexports (for haddock hyperlinks)
        , module Imj.Game.Hamazed.World.Types
        , module Imj.Graphics.ParticleSystem.Design.Create
        ) where

import           Imj.Prelude

import           Imj.Game.Hamazed.Types
import           Imj.Game.Hamazed.World.Types
import           Imj.Geo.Discrete
import           Imj.Graphics.ParticleSystem.Design.Create
import           Imj.Timing
import           Imj.Util hiding(range)

-- | A foreseen game or animation update.
data Deadline = Deadline {
    _deadlineTime :: !(Time Point System)
    -- ^ At which time should the update become visible to the user.
  , _deadlinePriority :: !Int
  , _deadlineType :: !DeadlineType
} deriving(Eq, Show)



data EventGroup = EventGroup {
    events :: ![UpdateEvent]
  , _eventGroupHasPrincipal :: !Bool
  , _eventGroupUpdateDuration :: !(Time Duration System)
  , _eventGroupVisibleTimeRange :: !(Maybe (Range (Time Point System)))
  -- ^ Range of /visible/ events deadlines
}

type UpdateEvent = Either ServerEvent Event

--------------------------------------------------------------------------------
newtype ServerStepIdx = ServerStepIdx Int
  deriving(Eq, Show)

--------------------------------------------------------------------------------
-- Types of data transmitted Client -> Server.
--------------------------------------------------------------------------------
data ClientAction = ClientAction {
    _state :: !ClientState
  , _evt :: !ClientEvent
} deriving(Eq, Show)

data ClientState = ClientState {
    _lastHandledStepIdx :: !ServerStepIdx
} deriving(Eq, Show)

-- | An event generated by the client, sent to the server.
data ClientEvent = Action !ActionTarget !Direction
                 -- ^ A player action on an 'ActionTarget' in a 'Direction'.
  deriving(Eq, Show)

{- Visual representation of client events where 2 players play on the same multiplayer game:

Ax = acceleration of ship x
Lx = laser shot of ship x
.  = end of a game period

        >>> time >>>
 . . . A1 . . A1 A2 L2 L1 .
              ^^^^^ ^^^^^
              |     |
              |     laser shots can't be aggregated.
              |
              accelerations can be aggregated, their order within a period is unimportant.

The order in which L1 L2 are handled is the order in which they are received by the server.
This is /unfair/ to the players because one player (due to network delays) could have rendered the
last period 100ms before the other, thus having a noticeable advantage over the other player.
We could be more fair by keeping track of the perceived time on the player side:

in 'ClientAction' we could store the difference between the system time of the action
and the system time at which the last motion update was presented to the player.

Hence, to know how to order close laser shots, if the ships are on the same row or column,
the server should wait a little (max. 50 ms?) to see if the other player makes a
perceptually earlier shot.
-}
--------------------------------------------------------------------------------
-- Types of data transmitted Server -> Client.
--------------------------------------------------------------------------------
data ClientActionResult = ClientActionResult {
    _steps :: ![GameStep]
  {- ^ Steps to handle in order to be up-to-date with the last completed server step.

  Hence, if a player sends an action according to what he/she sees at that moment,
  it's possible that the action will be applied to a later period.
  -}
  , _lastStepIdx :: !ServerStepIdx
  -- ^ This index should be stored by the client and sent along with
} deriving(Eq, Show)

-- | 'PeriodicMotion' aggregates the accelerations of all ships during a game period.
data GameStep = PeriodicMotion {
  _shipsAccelerations :: ![(ShipId, Coords Vel)]
  -- ^ The sum of player-induced accelerations
}
              | LaserShot !ShipId !Direction
              deriving(Generic, Eq, Show, Binary)

newtype ServerEvent = ServerEvent GameStep
  deriving(Generic, Show, Binary)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

data DeadlineType = AnimateParticleSystem ParticleSystemKey
                  -- ^ Update one or more 'ParticleSystem's.
                  | DisplayContinueMessage
                  -- ^ Show the /Hit a key to continue/ message
                  | AnimateUI
                  -- ^ Update the inter-level animation
                  deriving(Eq, Show)

data Event = Configuration !Char
           -- ^ Configures game parameters
           | CycleRenderingOptions
           -- ^ Changes the font used to render
           | StartGame
           -- ^ To transition from configuration mode to play mode.
           | Timeout !Deadline
           -- ^ The 'Deadline' that needs to be handled immediately.
           | StartLevel !Int
           -- ^ New level.
           | EndGame
           -- ^ End of game.
           | Interrupt !MetaAction
           -- ^ A game interruption.
           |Â ToggleEventRecording
           deriving(Eq, Show)

data MetaAction = Quit
                -- ^ The player decided to quit the game.
                | Help
                -- ^ The player wants to read the help page /(Not implemented yet)/
                deriving(Eq, Show)

data ActionTarget = Ship
                  -- ^ The player wants to accelerate the 'BattleShip'
                  | Laser
                  -- ^ The player wants to shoot with the laser.
                  deriving(Eq, Show)
