{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE AllowAmbiguousTypes #-}

module Imj.Game.Hamazed.State.Types
      (
      -- * Client / GameLogic
        Client(..)
      , GameLogic(..)
      , EventsForClient(..)
      , Game(..)
      , AnimatedLine(..)
      , GenEvent(..)
      , UpdateEvent
      , EventGroup(..)
      -- * AppState type
      , AppState(..)
      , RecordMode(..)
      , OccurencesHist(..)
      , Occurences(..)
      , EventCategory(..)
      -- * EventGroup
      , isPrincipal
      , mkEmptyGroup
      , visible
      , count
      , tryGrow
      -- * Access
      , getGameState
      , getPlayers
      , getPlayer
      , getChatMode
      , getMyId
      , getGameConnection
      , getChat
      , getWorldParameters
      , getCurScreen
      , getLastRenderTime
      , hasVisibleNonRenderedUpdates
      -- * Modify
      , putGame
      , putCurScreen
      , putGameState
      , putPlayer
      , putPlayers
      , putGameConnection
      , putWorldParameters
      , putDrawnState
      , stateChat
      , takeKeys
      -- * reexports
      , MonadState
      , TQueue
      , gets
      ) where

import           Imj.Prelude
import           Prelude(length)

import           Control.Concurrent.STM(TQueue)
import           Control.Monad.State.Class(MonadState)
import           Control.Monad.IO.Class(MonadIO)
import           Control.Monad.Reader.Class(MonadReader)
import           Control.Monad.State.Strict(gets, state, modify')
import           Data.Attoparsec.Text(Parser)
import qualified Data.Map.Strict as Map
import           Data.Map.Strict((!?),Map)

import           Imj.Categorized
import           Imj.ClientView.Types
import           Imj.Event
import           Imj.Game.Hamazed.Loop.Event.Priorities
import           Imj.Game.Hamazed.Network.Class.AsyncGroups
import           Imj.Graphics.Class.Draw
import           Imj.Graphics.Class.HasSizedFace
import           Imj.Graphics.Class.Render
import           Imj.Graphics.Interpolation.Evolution
import           Imj.Graphics.ParticleSystem
import           Imj.Graphics.RecordDraw
import           Imj.Graphics.Screen
import           Imj.Graphics.UI.RectContainer
import           Imj.Game.Hamazed.Network.Types
import           Imj.Input.Types
import           Imj.ServerView.Types

import           Imj.Game.Hamazed.Chat
import           Imj.Game.Hamazed.Loop.Timing
import           Imj.Geo.Discrete.Types
import           Imj.Graphics.Text.ColorString

class GameLogic (GameLogicT c)
  => Client c
 where
  type GameLogicT c

  -- | Send a 'ClientEvent' to the server.
  sendToServer' :: (MonadIO m)
                => c
                -> ClientEvent (ServerT (GameLogicT c))
                -> m ()

  -- | The queue containing events that should be handled by the client.
  serverQueue :: c -> TQueue (EventsForClient (GameLogicT c))

  -- | Fill 'serverQueue'
  writeToClient' :: (MonadIO m)
                 => c -> EventsForClient (GameLogicT c) -> m ()

data EventsForClient g =
    FromClient !(Event (ClientOnlyEvtT g))
  |Â FromServer !(ServerEvent (ServerT g))
  deriving(Generic)
instance (GameLogic g) => Show (EventsForClient g) where
  show (FromClient e) = show ("FromClient", e)
  show (FromServer e) = show ("FromServer", e)

{- Regroups all kinds of events. -}
data GenEvent g =
    Evt {-unpack sum-} !(Event (ClientOnlyEvtT g))
    -- ^ Are generated by the client and can be handled by the client immediately.
  | CliEvt {-unpack sum-} !(ClientEvent (ServerT g))
    -- ^ Are generated by the client but can't be handled by the client, and are sent to the game server.
  | SrvEvt {-unpack sum-} !(ServerEvent (ServerT g))
    -- ^ Are generated by the game server or by the client, and can be handled by the client immediately.
    deriving(Generic)
instance GameLogic g => Show (GenEvent g) where
  show (Evt e) = show("Evt",e)
  show (CliEvt e) = show("CliEvt",e)
  show (SrvEvt e) = show("SrvEvt",e)

type ParticleSystems = Map ParticleSystemKey (Prioritized ParticleSystem)

-- | 'GameLogic' Formalizes the client-side logic of the game.
-- The dual (server-side logic of the game) is 'Server'.
class (Server (ServerT g)
     , Categorized (ClientOnlyEvtT g)
     , Show (ClientOnlyEvtT g))
      =>
     GameLogic g
     where

  type ServerT g = (r :: *) | r -> g

  type ClientOnlyEvtT g = (r :: *) | r -> g
  -- ^ Events generated on the client and handled by the client.

  commandParser :: Parser (Either Text (Command (ServerT g)))

  initialGame :: (MonadIO m)
              => Screen -> m g

  -- | Called on each change in screen dimensions.
  onTargetSizeChanged :: (MonadState (AppState g) m
                        , MonadReader e m, Canvas e
                        , MonadIO m)
                      => Size -> m ()

  -- | Either the count of players, or the name / color of some player changed.
  onPlayersChanged :: MonadState (AppState g) m => m ()

  -- | Maps a 'Key' to a 'GenEvent'
  keyMapForOngoingState :: (GameLogicT e ~ g
                           , MonadState (AppState g) m
                           , MonadReader e m, Client e)
                           => Key -> StateValue -> m (Maybe (GenEvent g))

  -- | Handle events sent by the server.
  onServerEvent :: (g ~ GameLogicT e
                  , MonadState (AppState g) m
                  , MonadReader e m, Client e, Render e, HasSizedFace e, AsyncGroups e
                  , MonadIO m)
                => ServerEventT (ServerT g) -> m ()

  onClientEvent :: (g ~ GameLogicT e
                  , MonadState (AppState g) m
                  , MonadReader e m, Client e, Render e, HasSizedFace e
                  , MonadIO m)
              => ClientOnlyEvtT g -> m ()

  onUpdateUIAnim :: (GameLogicT e ~ g
                   , MonadState (AppState (GameLogicT e)) m
                   , MonadReader e m, Client e
                   , MonadIO m)
                 => Time Point System
                 -> m ()

  getDeadlines :: g -> [Deadline]

  particleSystems :: g -> ParticleSystems
  putParticleSystems :: ParticleSystems -> g -> g

  getGameSize :: (MonadState (AppState g) m)
              => m Size

  drawGame :: (GameLogicT e ~ g
             , MonadState (AppState (GameLogicT e)) m
             , MonadReader e m, Draw e
             , MonadIO m)
           => m RectContainer
           -- ^ Returns the drawn region

data EventGroup g = EventGroup {
    events :: ![UpdateEvent g]
  , _eventGroupHasPrincipal :: !Bool
  , _eventGroupUpdateDuration :: !(Time Duration System)
  , _eventGroupVisibleTimeRange :: !(Maybe (TimeRange System))
  -- ^ TimeRange of /visible/ events deadlines
}

-- | Regroups events that can be handled immediately by the client.
type UpdateEvent g = Either (ServerEvent (ServerT g)) (Event (ClientOnlyEvtT g))

-- | No 2 principal events can be part of the same 'EventGroup'.
-- It allows to separate important game action on different rendered frames.
isPrincipal :: UpdateEvent g -> Bool
isPrincipal (Right e) = case e of
  (Timeout (Deadline _ _ (AnimateParticleSystem _))) -> False
  (Timeout (Deadline _ _ AnimateUI)) -> False
  _ -> True
isPrincipal (Left _) = True

mkEmptyGroup :: EventGroup g
mkEmptyGroup = EventGroup [] False zeroDuration Nothing

visible :: EventGroup g -> Bool
visible (EventGroup _ _ _ Nothing) = False
visible _ = True

count :: EventGroup g -> Int
count (EventGroup l _ _ _) = length l

tryGrow :: Maybe (UpdateEvent g) -> EventGroup g -> IO (Maybe (EventGroup g))
tryGrow Nothing group
 | null $ events group = return $ Just group -- Keep the group opened to NOT do a render
 | otherwise = return Nothing -- to do a render
tryGrow (Just e) (EventGroup l hasPrincipal updateTime range)
 | hasPrincipal && principal = return Nothing -- we don't allow two principal events in the same group
 | updateTime > fromSecs 0.01 = return Nothing -- we limit the duration of updates, to keep a stable render rate
 | otherwise = maybe mkRangeSingleton (flip extendRange) range <$> time >>= \range' -> return $
    let -- so that no 2 updates of the same particle system are done in the same group:
        maxDiameter = particleSystemDurationToSystemDuration $ 0.99 .* particleSystemPeriod
    in if timeSpan range' > maxDiameter
      then
        Nothing
      else
        withEvent $ Just range'
 where
  !principal = isPrincipal e
  withEvent = Just . EventGroup (e:l) (hasPrincipal || principal) updateTime
  time = case e of
    Right (Timeout (Deadline t _ _)) -> return t
    _ -> getSystemTime


data Game g = Game {
    getClientState :: {-# UNPACK #-} !ClientState
  , getScreen :: {-# UNPACK #-} !Screen
  , getGameState' :: !g
  , getDrawnClientState :: ![( ColorString -- The raw message, just used to compare with new messages.
                                          -- For rendering, 'AnimatedLine' is used.
                          , AnimatedLine)]
  , getPlayers' :: !(Map ClientId Player)
  , _gameSuggestedPlayerName :: !(ConnectIdT (ServerT g))
  , getServerView' :: {-unpack sum-} !(ServerView (ServerT g))
  -- ^ The server that runs the game
  , connection' :: {-unpack sum-} !ConnectionStatus
  , getChat' :: !Chat
}


data AnimatedLine = AnimatedLine {
    getRecordDrawEvolution :: !(Evolution RecordDraw)
  , getALFrame :: !Frame
  , getALDeadline :: !(Maybe Deadline)
} deriving(Generic, Show)

data Occurences a = Occurences {
    _occurencesCount :: {-# UNPACK #-} !Int
  , _occurencesItem :: {-unpack sum-} !EventCategory
} deriving(Generic, Show)

data AppState g = AppState {
    timeAfterRender :: !(Time Point System)
  , game :: !(Game g)
  , eventsGroup :: !(EventGroup g)
  , _appStateEventHistory :: !OccurencesHist
  -- ^ Can record which events where handled, for debugging purposes.
  , _appStateRecordEvents :: !RecordMode
  -- ^ Should the handled events be recorded?
  , nextParticleSystemKey :: !ParticleSystemKey
  , _appStateDebug :: {-unpack sum-} !Bool
  -- ^ Print times and group information in the terminal.
}

data RecordMode = Record
                | DontRecord
                deriving(Eq)

data OccurencesHist = OccurencesHist {
    _occurencesHistList :: ![Occurences EventCategory]
  , _occurencesHistTailStr :: !ColorString
} deriving(Generic, Show)


{-# INLINABLE getGameState #-}
getGameState :: MonadState (AppState g) m => m g
getGameState = getGameState' <$> gets game

{-# INLINABLE getServerView #-}
getServerView :: MonadState (AppState g) m => m (ServerView (ServerT g))
getServerView = getServerView' <$> gets game

{-# INLINABLE getChatMode #-}
getChatMode :: MonadState (AppState g) m => m IsEditing
getChatMode = getIsEditing <$> getChat

{-# INLINABLE getChat #-}
getChat :: MonadState (AppState g) m => m Chat
getChat = getChat' <$> gets game

{-# INLINABLE getCurScreen #-}
getCurScreen :: MonadState (AppState g) m => m Screen
getCurScreen = getScreen <$> gets game

{-# INLINABLE putCurScreen #-}
putCurScreen :: MonadState (AppState g) m => Screen -> m ()
putCurScreen s = gets game >>= \g -> putGame $ g { getScreen = s }

{-# INLINABLE getLastRenderTime #-}
getLastRenderTime :: MonadState (AppState g) m => m (Time Point System)
getLastRenderTime = gets timeAfterRender

{-# INLINABLE putGame #-}
putGame :: MonadState (AppState g) m => Game g -> m ()
putGame g = modify' $ \s -> s { game = g }

{-# INLINABLE putServer #-}
putServer :: MonadState (AppState g) m => (ServerView (ServerT g)) -> m ()
putServer s =
  gets game >>= \g -> putGame $ g {getServerView' = s}

{-# INLINABLE putGameState #-}
putGameState :: MonadState (AppState g) m => g -> m ()
putGameState s =
  gets game >>= \g -> putGame $ g {getGameState' = s}

{-# INLINABLE putGameConnection #-}
putGameConnection :: MonadState (AppState g) m => ConnectionStatus -> m ()
putGameConnection c =
  gets game >>= \g -> putGame $ g {connection' = c}

{-# INLINABLE getGameConnection #-}
getGameConnection :: MonadState (AppState g) m => m ConnectionStatus
getGameConnection = connection' <$> gets game

{-# INLINABLE getMyId #-}
getMyId :: MonadState (AppState g) m => m (Maybe ClientId)
getMyId =
  (\case
    Connected myId -> Just myId
    _ -> Nothing) <$> getGameConnection

{-# INLINABLE putWorldParameters #-}
putWorldParameters :: MonadState (AppState g) m => ServerViewContentT (ServerT g) -> m ()
putWorldParameters p =
  getServerView >>= \s@(ServerView _ c) ->
    putServer s { serverContent = c { cachedContent = Just p } }

{-# INLINABLE getWorldParameters #-}
getWorldParameters :: MonadState (AppState g) m => m (Maybe (ServerViewContentT (ServerT g)))
getWorldParameters =
  cachedContent . serverContent <$> getServerView

{-# INLINABLE getPlayers #-}
getPlayers :: MonadState (AppState g) m => m (Map ClientId Player)
getPlayers = getPlayers' <$> gets game

{-# INLINABLE getPlayer #-}
getPlayer :: MonadState (AppState g) m => ClientId -> m (Maybe Player)
getPlayer i = flip (!?) i <$> getPlayers

{-# INLINABLE putPlayers #-}
putPlayers :: MonadState (AppState g) m => Map ClientId Player -> m ()
putPlayers m = gets game >>= \g -> putGame g {getPlayers' = m}

{-# INLINABLE putPlayer #-}
putPlayer :: MonadState (AppState g) m => ClientId -> Player -> m ()
putPlayer sid player = getPlayers >>= \names -> putPlayers $ Map.insert sid player names

{-# INLINABLE takeKeys #-}
takeKeys :: MonadState (AppState g) m => Int -> m [ParticleSystemKey]
takeKeys n
  | n <= 0 = return []
  | otherwise =
      state $ \s ->
        let key = nextParticleSystemKey s
            endKey = key + fromIntegral n
        in ([key..pred endKey], s {nextParticleSystemKey = endKey })

{-# INLINABLE putDrawnState #-}
putDrawnState :: (MonadState (AppState g) m)
              => [(ColorString, AnimatedLine)]
              -> m ()
putDrawnState i =
  gets game >>= \g -> putGame $ g { getDrawnClientState = i }

{-# INLINABLE stateChat #-}
stateChat :: MonadState (AppState g) m => (Chat -> (Chat, a)) -> m a
stateChat f =
  gets game >>= \g -> do
    let (newChat, v) = f $ getChat' g
    putGame $ g { getChat' = newChat }
    return v

{-# INLINABLE hasVisibleNonRenderedUpdates #-}
hasVisibleNonRenderedUpdates :: MonadState (AppState g) m => m Bool
hasVisibleNonRenderedUpdates =
  visible <$> gets eventsGroup
