{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}

{-|
This is a multiplayer game where every player uses the keyboard as a synthesizer.

The music is shared between all players.
 -}

module Main where

import           Data.Maybe(maybeToList)
import           Control.DeepSeq(NFData)
import           Data.Proxy(Proxy(..))
import           Data.Binary(Binary(..))
import           Data.Map.Strict(Map)
import qualified Data.Map.Strict as Map
import qualified Data.Set as Set
import           GHC.Generics(Generic)
import qualified Graphics.UI.GLFW as GLFW(Key(..), KeyState(..))

import           Imj.Categorized
import           Imj.Game.App(runGame)
import           Imj.Game.Class
import           Imj.Game.Command
import           Imj.Game.Modify
import           Imj.Game.Status
import           Imj.Geo.Discrete.Types
import           Imj.Graphics.Class.Positionable
import           Imj.Graphics.UI.Colored
import           Imj.Graphics.Color
import           Imj.Graphics.Screen
import           Imj.Graphics.UI.RectContainer
import           Imj.Music.Types
import           Imj.Music.Compose
import           Imj.Server.Class hiding(Do)
import           Imj.Server.Connection
import           Imj.Server.Types

-- 'Proxy' is used to "tell" the type system what is the type of game:

main :: IO ()
main = runGame (Proxy :: Proxy SynthsGame)

-- | This implements the client-side logic of the game
newtype SynthsGame = SynthsGame PianoState
  deriving(Show)

-- | 'IncServer' is the game-specific state of the server. It holds nothing in our case,
-- because the server just broadcasts player events:
newtype SynthsServer = SynthsServer PianoState
  deriving(Generic)
instance NFData SynthsServer
thePianoValue :: SynthsServer -> PianoState
thePianoValue (SynthsServer x) = x

-- | This represents events generated by the server, sent to the clients.
-- the server will send music events, which are generic events so we don'T need any specific
-- event here.
newtype SynthsServerEvent =
  PianoValue PianoState
  deriving(Generic,NFData,Binary, Show)
instance Categorized SynthsServerEvent

-- | This represents events generated by the client and sent to the server.
data SynthClientEvent =
    PlayNote !Music !Instrument
  deriving(Show,Generic)
instance Binary SynthClientEvent
instance Categorized SynthClientEvent

instance GameExternalUI SynthsGame where

  gameWindowTitle = const "Play some music!"

  -- NOTE this is never called unless 'putIGame' was called once.
  -- It makes sense, since we are passed a 'SynthsGame', and before the first call to putIGame,
  -- no 'SynthsGame' exist.
  getViewport _ (Screen _ center) (SynthsGame _) =
    mkCenteredRectContainer center $ Size 10 100

data SynthsStatefullKeys
instance GameStatefullKeys SynthsGame SynthsStatefullKeys where

  mapStateKey _ k s _ _ =
    return $ CliEvt . ClientAppEvt . flip PlayNote SineSynth <$> n
   where
    n = maybe Nothing (\noteSpec -> case s of
      GLFW.KeyState'Pressed -> Just $ StartNote noteSpec 1
      GLFW.KeyState'Released -> Just $ StopNote noteSpec
      GLFW.KeyState'Repeating -> Nothing) $ keyToNote k
    keyToNote = \case
      -- NOTE GLFW uses the US keyboard layout to name keys: https://en.wikipedia.org/wiki/British_and_American_keyboards
      -- lower keys
      GLFW.Key'Z -> Just $ NoteSpec Do $ noOctave - 1
      GLFW.Key'S -> Just $ NoteSpec Réb $ noOctave - 1
      GLFW.Key'X -> Just $ NoteSpec Ré $ noOctave - 1
      GLFW.Key'D -> Just $ NoteSpec Mib $ noOctave - 1
      GLFW.Key'C -> Just $ NoteSpec Mi $ noOctave - 1
      GLFW.Key'V -> Just $ NoteSpec Fa $ noOctave - 1
      GLFW.Key'G -> Just $ NoteSpec Solb $ noOctave - 1
      GLFW.Key'B -> Just $ NoteSpec Sol $ noOctave - 1
      GLFW.Key'H -> Just $ NoteSpec Lab $ noOctave - 1
      GLFW.Key'N -> Just $ NoteSpec La $ noOctave - 1
      GLFW.Key'J -> Just $ NoteSpec Sib $ noOctave - 1
      GLFW.Key'M -> Just $ NoteSpec Si $ noOctave - 1
      GLFW.Key'Comma -> Just $ NoteSpec Do $ noOctave + 0
      GLFW.Key'L -> Just $ NoteSpec Réb $ noOctave + 0
      GLFW.Key'Period -> Just $ NoteSpec Ré $ noOctave + 0
      GLFW.Key'Semicolon -> Just $ NoteSpec Mib $ noOctave + 0
      GLFW.Key'Slash -> Just $ NoteSpec Mi $ noOctave + 0
      -- upper keys
      GLFW.Key'Q -> Just $ NoteSpec Do $ noOctave + 0
      GLFW.Key'2 -> Just $ NoteSpec Réb $ noOctave + 0
      GLFW.Key'W -> Just $ NoteSpec Ré $ noOctave + 0
      GLFW.Key'3 -> Just $ NoteSpec Mib $ noOctave + 0
      GLFW.Key'E -> Just $ NoteSpec Mi $ noOctave + 0
      GLFW.Key'R -> Just $ NoteSpec Fa $ noOctave + 0
      GLFW.Key'5 -> Just $ NoteSpec Solb $ noOctave + 0
      GLFW.Key'T -> Just $ NoteSpec Sol $ noOctave + 0
      GLFW.Key'6 -> Just $ NoteSpec Lab $ noOctave + 0
      GLFW.Key'Y -> Just $ NoteSpec La $ noOctave + 0
      GLFW.Key'7 -> Just $ NoteSpec Sib $ noOctave + 0
      GLFW.Key'U -> Just $ NoteSpec Si $ noOctave + 0
      GLFW.Key'I -> Just $ NoteSpec Do $ noOctave + 1
      GLFW.Key'9 -> Just $ NoteSpec Réb $ noOctave + 1
      GLFW.Key'O -> Just $ NoteSpec Ré $ noOctave + 1
      GLFW.Key'0 -> Just $ NoteSpec Mib $ noOctave + 1
      GLFW.Key'P -> Just $ NoteSpec Mi $ noOctave + 1
      GLFW.Key'LeftBracket -> Just $ NoteSpec Fa $ noOctave + 1
      GLFW.Key'Equal -> Just $ NoteSpec Solb $ noOctave + 1
      GLFW.Key'RightBracket -> Just $ NoteSpec Sol $ noOctave + 1
      _ -> Nothing

instance GameLogic SynthsGame where

  -- A 'GameLogic' instance is tied to a 'Server' instance via the associated type 'ServerT'
  type ServerT SynthsGame = SynthsServer
  type StatefullKeysT SynthsGame = SynthsStatefullKeys

  mapInterpretedKey _ _ = return Nothing

  onClientOnlyEvent = \case
    () -> return ()
  -- TODO add particle systems on each note (we'll need to send a specific server event)
  onServerEvent = \case
    PianoValue x -> withAnim $ putIGame $ SynthsGame x -- TODO force withAnim when using putIGame ?

instance GameDraw SynthsGame where
  drawBackground (Screen _ center) (SynthsGame piano) = do
    let minNote = NoteSpec Do  $ noOctave - 1
        maxNote = NoteSpec Sol $ noOctave + 1
        str = drawKeys minNote maxNote piano
    drawAligned_ (Colored (onBlack $ rgb 3 1 2) str) $ mkCentered center
    return center

instance ServerInit SynthsServer where

  type ClientViewT SynthsServer = ()

  mkInitialState = return ((), SynthsServer mkEmptyPiano)

  mkInitialClient = ()

instance ServerInParallel SynthsServer

instance ServerClientLifecycle SynthsServer where

  clientCanJoin _ = do
    -- A client has just connected, we make it be part of the current game:
    notifyClient' $ EnterState $ Included $ PlayLevel Running
    return True

instance ServerClientHandler SynthsServer where

  type StateValueT  SynthsServer = GameStateValue -- This is required

  type ClientEventT SynthsServer = SynthClientEvent

  handleClientEvent (PlayNote n i) = do
    modifyState $ \(SynthsServer p) -> SynthsServer $ case n of
      StartNote spec _ -> addNote spec p
      StopNote spec -> removeNote spec p
    pv <- PianoValue <$> getsState thePianoValue
    notifyEveryoneN' [PlayMusic n i, ServerAppEvt pv]

instance Server SynthsServer where

  type ServerEventT SynthsServer = SynthsServerEvent

  greetNewcomer' = -- Send the currently started notes so that the newcomer
                   -- hears exactly what other players are hearing.
    (\(PianoState m) -> map (flip PlayMusic SineSynth . flip StartNote 1) (Map.keys m) ) <$> getsState thePianoValue
  greetNewcomer =
    (:[]) . PianoValue <$> getsState thePianoValue

instance ServerCmdParser SynthsServer where

-- | The keys currently pressed. Note that the same key can be pressed twice because
-- the lower and upper keyboards overlapp.
data PianoState = PianoState !(Map NoteSpec Int)
  deriving(Generic, Show)
instance Binary PianoState
instance NFData PianoState

mkEmptyPiano :: PianoState
mkEmptyPiano = PianoState mempty

addNote :: NoteSpec -> PianoState -> PianoState
addNote n (PianoState s) = PianoState $ Map.insertWith (+) n 1 s

removeNote :: NoteSpec -> PianoState -> PianoState
removeNote n (PianoState s) =
  PianoState $
    Map.alter
      (maybe
        (error "logic") -- we remove an inexistant note
        (\prev -> case prev - 1 of
            0 -> Nothing
            i ->
              if i > 0
                then
                  Just i
                else
                  error "logic"))
      n
      s

drawKeys :: NoteSpec
         -- ^ From
         -> NoteSpec
         -- ^ To
         -> PianoState
         -> String
drawKeys from to (PianoState m) =
  go [] [from..to] $ Set.toAscList $ Map.keysSet m
 where
  go l [] _ = reverse l
  go l (k@(NoteSpec n _):ks) remainingPressed =
    case remainingPressed of
      [] -> go' freeChar remainingPressed
      p:ps ->
        if p == k
          then
            go' pressedChar ps
          else
            go' freeChar remainingPressed
   where
    go' c remPressed = go (maybeToList space ++ [c] ++ l) ks remPressed

    space = case ks of
      [] -> Nothing
      (NoteSpec s _):_ -> case s of
        Fa -> Just ' '
        Do -> Just ' '
        _ -> Nothing

    freeChar
      | naturalNote n = '-'
      | otherwise = '*'--'\''

    pressedChar
      | naturalNote n = '_'
      | otherwise = '.'
