{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}

{-|
This is a multiplayer game where every player uses the keyboard as a synthesizer.

The music is shared between all players.
 -}

module Main where

import           Control.DeepSeq(NFData)
import           Data.Proxy(Proxy(..))
import           Data.Binary(Binary(..))
import           GHC.Generics(Generic)
import qualified Graphics.UI.GLFW as GLFW(Key(..), KeyState(..))

import           Imj.Categorized
import           Imj.Game.App(runGame)
import           Imj.Game.Class
import           Imj.Game.Status
import           Imj.Geo.Discrete.Types
import           Imj.Graphics.Screen
import           Imj.Graphics.UI.RectContainer
import           Imj.Music
import           Imj.Server.Class hiding(Do)
import           Imj.Server.Connection
import           Imj.Server.Types

-- 'Proxy' is used to "tell" the type system what is the type of game:

main :: IO ()
main = runGame (Proxy :: Proxy SynthsGame)

-- | This implements the client-side logic of the game
newtype SynthsGame = SynthsGame ()

-- | 'IncServer' is the game-specific state of the server. It holds nothing in our case,
-- because the server just broadcasts player events:
newtype SynthsServer = SynthsServer ()
  deriving(Generic)
instance NFData SynthsServer

-- | This represents events generated by the server, sent to the clients.
-- the server will send music events, which are generic events so we don'T need any specific
-- event here.
type SynthsServerEvent = ()

-- | This represents events generated by the client and sent to the server.
data SynthClientEvent =
    PlayNote !Music !Instrument
  deriving(Show,Generic)
instance Binary SynthClientEvent
instance Categorized SynthClientEvent

instance GameExternalUI SynthsGame where

  gameWindowTitle = const "Play some music!"

  -- This defines the size of the outer frame you see when running the game.
  -- Note that the size depends on the counter value:
  getViewport _ (Screen _ center) (SynthsGame _) =
    mkCenteredRectContainer center $ Size 10 10

data SynthsStatefullKeys
instance GameStatefullKeys SynthsGame SynthsStatefullKeys where

  mapStateKey _ k s _ _ =
    return $ CliEvt . ClientAppEvt . flip PlayNote SineSynth <$> n
   where
    n = maybe Nothing (\noteSpec -> case s of
      GLFW.KeyState'Pressed -> Just $ StartNote noteSpec 1
      GLFW.KeyState'Released -> Just $ StopNote noteSpec
      GLFW.KeyState'Repeating -> Nothing) $ keyToNote k
    keyToNote = \case
      GLFW.Key'Z -> Just $ NoteSpec Do $ noOctave - 1
      GLFW.Key'S -> Just $ NoteSpec Réb $ noOctave - 1
      GLFW.Key'X -> Just $ NoteSpec Ré $ noOctave - 1
      GLFW.Key'D -> Just $ NoteSpec Mib $ noOctave - 1
      GLFW.Key'C -> Just $ NoteSpec Mi $ noOctave - 1
      GLFW.Key'V -> Just $ NoteSpec Fa $ noOctave - 1
      GLFW.Key'G -> Just $ NoteSpec Solb $ noOctave - 1
      GLFW.Key'B -> Just $ NoteSpec Sol $ noOctave - 1
      GLFW.Key'H -> Just $ NoteSpec Lab $ noOctave - 1
      GLFW.Key'N -> Just $ NoteSpec La $ noOctave - 1
      GLFW.Key'J -> Just $ NoteSpec Sib $ noOctave - 1
      GLFW.Key'M -> Just $ NoteSpec Si $ noOctave - 1
      GLFW.Key'Comma -> Just $ NoteSpec Do $ noOctave + 0
      GLFW.Key'L -> Just $ NoteSpec Réb $ noOctave + 0
      GLFW.Key'Period -> Just $ NoteSpec Ré $ noOctave + 0
      GLFW.Key'Semicolon -> Just $ NoteSpec Mib $ noOctave + 0
      GLFW.Key'Slash -> Just $ NoteSpec Mi $ noOctave + 0

      GLFW.Key'Q -> Just $ NoteSpec Do $ noOctave + 0
      GLFW.Key'2 -> Just $ NoteSpec Réb $ noOctave + 0
      GLFW.Key'W -> Just $ NoteSpec Ré $ noOctave + 0
      GLFW.Key'3 -> Just $ NoteSpec Mib $ noOctave + 0
      GLFW.Key'E -> Just $ NoteSpec Mi $ noOctave + 0
      GLFW.Key'R -> Just $ NoteSpec Fa $ noOctave + 0
      GLFW.Key'5 -> Just $ NoteSpec Solb $ noOctave + 0
      GLFW.Key'T -> Just $ NoteSpec Sol $ noOctave + 0
      GLFW.Key'6 -> Just $ NoteSpec Lab $ noOctave + 0
      GLFW.Key'Y -> Just $ NoteSpec La $ noOctave + 0
      GLFW.Key'7 -> Just $ NoteSpec Sib $ noOctave + 0
      GLFW.Key'U -> Just $ NoteSpec Si $ noOctave + 0
      GLFW.Key'I -> Just $ NoteSpec Do $ noOctave + 1
      GLFW.Key'9 -> Just $ NoteSpec Réb $ noOctave + 1
      GLFW.Key'O -> Just $ NoteSpec Ré $ noOctave + 1
      GLFW.Key'0 -> Just $ NoteSpec Mib $ noOctave + 1
      GLFW.Key'P -> Just $ NoteSpec Mi $ noOctave + 1
      GLFW.Key'LeftBracket -> Just $ NoteSpec Fa $ noOctave + 1
      GLFW.Key'Equal -> Just $ NoteSpec Solb $ noOctave + 1
      GLFW.Key'RightBracket -> Just $ NoteSpec Sol $ noOctave + 1
      _ -> Nothing

instance GameLogic SynthsGame where

  -- A 'GameLogic' instance is tied to a 'Server' instance via the associated type 'ServerT'
  type ServerT SynthsGame = SynthsServer
  type StatefullKeysT SynthsGame = SynthsStatefullKeys

  mapInterpretedKey _ _ = return Nothing

  onClientOnlyEvent = \case
    () -> return ()
  -- TODO add particle systems on each note (we'll need to send a specific server event)
  onServerEvent  = \case
    () -> return ()

instance GameDraw SynthsGame

instance ServerInit SynthsServer where

  type ClientViewT SynthsServer = ()

  mkInitialState = return ((), SynthsServer ())

  mkInitialClient = ()

instance ServerInParallel SynthsServer

instance ServerClientLifecycle SynthsServer where

  clientCanJoin _ = do
    -- A client has just connected, we make it be part of the current game:
    notifyClient' $ EnterState $ Included $ PlayLevel Running
    return True

instance ServerClientHandler SynthsServer where

  type StateValueT  SynthsServer = GameStateValue -- This is required

  type ClientEventT SynthsServer = SynthClientEvent

  handleClientEvent (PlayNote n i) =
    notifyEveryone' $ PlayMusic n i

instance Server SynthsServer where

  type ServerEventT SynthsServer = SynthsServerEvent

instance ServerCmdParser SynthsServer where
