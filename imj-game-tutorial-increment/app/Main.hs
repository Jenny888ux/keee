{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Main where

import           Data.Bool(bool)
import           Data.Monoid((<>))
import           Control.DeepSeq(NFData)
import           Control.Monad.State.Strict(modify', gets)
import           Data.Attoparsec.Text(skipSpace, atEnd, takeText)
import           Data.Text(unpack)
import           Data.Proxy(Proxy(..))
import           Data.Binary(Binary(..))
import           GHC.Generics(Generic)

import           Imj.Categorized
import           Imj.Game.App(runGame)
import           Imj.Game.Command
import           Imj.Game.Status
import           Imj.Game.Types
import           Imj.Geo.Discrete.Types
import           Imj.Graphics.Color.Types
import           Imj.Graphics.Screen
import           Imj.Graphics.Render.FromMonadReader(drawStr)
import           Imj.Graphics.UI.Chat
import           Imj.Graphics.UI.RectContainer
import           Imj.Input.Types
import           Imj.Server
import           Imj.Server.Class
import           Imj.Server.Connection
import           Imj.Server.Types
import           Imj.Util

-- 'Proxy' is used to "tell" the type system what is the type of game:

main :: IO ()
main = runGame (Proxy :: Proxy IncGame)

newtype Counter = Counter Int
  deriving(Generic, Binary, Show, NFData, Num, Integral, Real, Ord, Eq, Enum)

-- | This implements the client-side logic of the game
data IncGame = IncGame {
  theClientCounter :: !Counter
}

-- 'evenTriangle' is used to make the size of the frame vary with the counter:
evenTriangle :: Int -> Int
evenTriangle = (*) 2 . zigzag 0 5

-- The two main classes are 'GameLogic' (which acts client-side) and 'Server'
-- (which, as the name suggests, acts server-side).
--
-- 'GameLogic' knows about 'Server' via the associated type 'ServerT'

instance GameLogic IncGame where
  type ServerT IncGame = IncServer

  -- This defines the size of the outer frame:
  getViewport _ (Screen _ center) (IncGame n) =
    let i = evenTriangle $ fromIntegral n
    in mkCenteredRectContainer center $ Size (10+fromIntegral i) (10+fromIntegral i)

  keyMaps key _ = return $ case key of
    -- the space bar increments the counter
    AlphaNum ' ' -> Just $ CliEvt $ ClientAppEvt IncrementCounter
    _ -> Nothing

  onClientOnlyEvent = \case
    () -> return ()
  onServerEvent  = \case
    CounterValue value ->
      withAnim $
        putIGame $ IncGame value

  onClientCustomCmd ResetCounter =
    stateChat $ addMessage $ ChatMessage $ "The counter has been reset."

  drawForeground (Screen _ screenCenter) _ (IncGame counterValue) =
    -- The counter value is drawn in the center of the screen:
    drawStr (show counterValue) screenCenter $ LayeredColor black (rgb 5 4 2)

-- | This implements the server-side logic of the game
data IncServer = IncServer {
  theServerCounter :: !Counter
} deriving(Generic)
instance NFData IncServer

instance Server IncServer where
  type StateValueT   IncServer = GameStateValue

  type ClientEventT        IncServer = IncClientEvent
  type ServerEventT        IncServer = IncServerEvent
  type CustomCmdT          IncServer = IncCommand

  type ValuesT       IncServer = ()
  type ClientViewT   IncServer = ()

  type ValueKeyT     IncServer = ()
  type ValueT        IncServer = ()
  type EnumValueKeyT IncServer = ()

  mkInitial _ =
    return ((),IncServer 0)

  mkInitialClient = ()

  greetNewcomer =
    (:[]) . CounterValue . theServerCounter <$> gets unServerState

  getValue () = return ()
  onPut ()    = return ()
  onDelta _ _ = return ()

  clientCanJoin _ = do
    -- A client has just connected, we make it be part of the current game:
    notifyClient' $ EnterState $ Included $ PlayLevel Running
    return True

  handleClientEvent IncrementCounter = do
    -- modify the global state (we are inside an MVar transaction so there is
    -- no race condition between different clients):
    modify' $ mapState $ \(IncServer n) -> IncServer $ n+1
    -- send the updated value to all clients:
    gets' theServerCounter >>= notifyEveryone . CounterValue

  acceptCommand ResetCounter = do
    -- modify the global state (we are inside an MVar transaction so there is
    -- no race condition between different clients):
    modify' $ mapState $ const $ IncServer 0
    -- send the updated value to all clients:
    gets' theServerCounter >>= notifyEveryone . CounterValue
    return $ Right ()

  cmdParser "reset" = do
    skipSpace
    atEnd >>= bool
      (takeText >>= \t -> fail $ unpack $ "Unexpected \"" <> t <> "\" (reset takes no parameter)" )
      (return $ Right $ RequestApproval $ CustomCmd ResetCounter)

  cmdParser cmd = fail $ "'" <> unpack cmd <> "' is an unknown command."

-- | This represents events generated by the client and sent to the server.
data IncClientEvent =
    IncrementCounter
  deriving(Show,Generic)
instance Binary IncClientEvent
instance Categorized IncClientEvent

data IncCommand = ResetCounter
  deriving(Show, Eq, Generic)
instance Binary IncCommand

-- | This represents events generated by the server, sent to the clients.
data IncServerEvent =
    CounterValue !Counter
  deriving(Show,Generic)
instance Binary IncServerEvent
instance Categorized IncServerEvent
