{-# OPTIONS_HADDOCK hide #-}

{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE FlexibleInstances #-}

module Imj.Graphics.Class.DiscreteInterpolation
        ( DiscreteInterpolation(..)
          -- * Reexport
        , module Imj.Graphics.Class.DiscreteDistance
        ) where

import           Imj.Prelude

import           Data.List(length)
import           Data.Text(pack)

import           Imj.Geo.Discrete
import           Imj.Graphics.Color.Types
import           Imj.Graphics.Class.DiscreteDistance
import           Imj.Graphics.Text.ColorString.Interpolation
import           Imj.Graphics.Text.ColorString
import           Imj.Util


{- | Instances should statisfy the following constraints:

* An interpolation between A and B starts at A and ends at B:

\( \forall (\, from, to)\, \in v, \)

@
    d = distance from to
    interpolate from to 0 == from
    interpolate from to d == to
@

* The interpolation path is composed of strictly distinct points:

@
    length $ nubOrd $ map (interpolate from to) [0..pred d] == d
@

* Given any points A,B belonging the path generated by an interpolation,
  the interpolation beween A and B will be the points of the path between A and B:

\( \forall med \in [\,0,d]\,, \forall low \in [\,0,med]\,, \forall high \in [\,med,d]\,, \)

@
    distance from med + distance med to == 1 + distance from to
    medVal = interpolate from to med
    interpolate from to low  == interpolate from medVal low
    interpolate from to high == interpolate medVal to $ high-med
@
-}
class (DiscreteDistance v) => DiscreteInterpolation v where
  -- | Implement this function if you want to interpolate /by value/, i.e the result of
  -- the interpolation between two \(v\) is a \(v\).
  interpolate :: v -- ^ first value
              -> v -- ^ last value
              -> Int -- ^ the current step
              -> v -- ^ the interpolated value

  interpolateSuccessive :: Successive v
                        -> Int
                        -> v
  interpolateSuccessive (Successive []) _ = error "empty successive"
  interpolateSuccessive (Successive [a]) _ = a
  interpolateSuccessive (Successive l@(a:b:_)) i
    | i <= 0      = a
    | i >= lf = interpolateSuccessive (Successive $ tail l) $ i-lf
    | otherwise = interpolate a b i
    where lf = pred $ distance a b

-- | Naïve interpolation.
instance DiscreteInterpolation Int where
  interpolate i i' progress =
    i + signum (i'-i) * clamp progress 0 (abs (i-i'))


-- | Interpolate in parallel between 2 lists : each pair of same-index elements
-- is interpolated at the same time.
instance (DiscreteInterpolation a)
      => DiscreteInterpolation ([] a) where
  interpolate l l' progress =
    zipWith (\e e' -> interpolate e e' progress) l $ assert (length l == length l') l'

-- | Using bresenham 2d line algorithm.
instance DiscreteInterpolation (Coords Pos) where
  interpolate c c' i
    | c == c' = c
    | otherwise =
        let lastFrame = pred $ fromIntegral $ bresenhamLength c c'
            -- TODO measure if "head . drop (pred n)"" is more optimal than "!! n"
            index = clamp i 0 lastFrame
        in head . drop index $ bresenham $ mkSegment c c'

-- | Using bresenham 3D algorithm in RGB space. Only valid between 2 'rgb' or 2 'gray'.
instance DiscreteInterpolation (Color8 a) where
  -- | The two input 'Color8' are supposed to be both 'rgb' or both 'gray'.
  interpolate c c' i
    | c == c' = c
    | otherwise =
        let lastFrame = pred $ fromIntegral $ bresenhamColor8Length c c'
            -- TODO measure if "head . drop (pred n)"" is more optimal than "!! n"
            index = clamp i 0 lastFrame
        in head . drop index $ bresenhamColor8 c c'

-- | First interpolate background color, then foreground color
instance DiscreteInterpolation LayeredColor where
  interpolate (LayeredColor bg fg) (LayeredColor bg' fg') i
    | i < lastBgFrame = LayeredColor (interpolate bg bg' i) fg
    | otherwise       = LayeredColor bg' $ interpolate fg fg' $ i - lastBgFrame
    where
      lastBgFrame = pred $ distance bg bg'

-- | First interpolating characters, then color.
instance DiscreteInterpolation ColorString where
  interpolate c1 c2 i =
    let c2' = simplify c2
        (c1', remaining) = interpolateChars (simplify c1) c2' i
    in ColorString $ map (\(char,color) -> (pack [char], color)) $
        if remaining >= 0
          then
            c1'
          else
            interpolateColors c1' c2' (negate remaining)

interpolateColors :: [(Char, LayeredColor)]
                  -- ^ from
                  ->[(Char, LayeredColor)]
                  -- ^ to
                  -> Int
                  -- ^ progress
                  -> [(Char, LayeredColor)]
interpolateColors c1 c2 i =
  let z (_, color) (char, color') = (char, interpolate color color' i)
  in  zipWith z c1 c2
