{-# LANGUAGE NoImplicitPrelude #-}

module Interpolation
         ( DiscretelyInterpolable(..)
         , evolve
         , mkEvolution
         , Evolution(..)
         -- | Reexports
         , module Iteration
         ) where

import           Imajuscule.Prelude

import           Iteration
import           Math


-- | The instances of this class should statisfy the following constraints:
--
-- For every {from, to} <- v
--
-- > d = distance from to
--
-- > interpolate from to 0 == from
-- > interpolate from to d == to
--
--   "The interpolation path is composed of distinct points"
--
-- > length $ nubOrd $ (interpolate from to) map [from..to] == d
--
--   "Given any points A,B belonging the path generated by an interpolation,
--     the interpolation beween A and B will be the points of the path between A and B"
--
-- For every med in [0..d]
--
-- > distance from med + distance med to == 1 + distance from to
-- > medVal = interpolate from to med
--
-- For every low  in [0..med]
-- For every high in [med..d]
--
-- > interpolate from to low  == interpolate from medVal low
-- > interpolate from to high == interpolate medVal to $ high-med
class (Eq v, Ord v)
   => DiscretelyInterpolable v where

  distance :: v -- ^ first value
           -> v -- ^ last value
           -> Int -- ^ the number of steps (including first and last) to go from first to last

  interpolate :: v -- ^ first value
              -> v -- ^ last value
              -> Int -- ^ the current step
              -> v -- ^ the interpolated value


instance DiscretelyInterpolable Int where
  distance i i' =
    1 + abs (i-i')
  interpolate i i' progress =
    i + signum (i'-i) * clamp progress 0 (abs (i-i'))


{-# INLINABLE mkEvolution #-} -- to allow specialization
mkEvolution :: DiscretelyInterpolable v
            => v
            -> v
            -> Float
            -- ^ duration in seconds
            -> Evolution v
mkEvolution from to duration =
  let nSteps = distance from to
  in Evolution from to (Frame (nSteps-1)) duration invQuartEaseInOut

data (DiscretelyInterpolable v)
   => Evolution v = Evolution {
    _evolutionFrom :: !v
  , _evolutionTo :: !v
  , _evolutionLastFrame :: !Frame
  , _evolutionDuration :: Float -- ^ Total duration in seconds
  , _evolutionInverseEase :: Float -> Float
}

{-# INLINABLE evolve #-} -- allow specialization
evolve :: DiscretelyInterpolable v
       => Evolution v
       -> Frame
       -- ^ current frame
       -> (v, Maybe Float)
       -- ^ the value, and maybe the time interval between this step and the next
evolve (Evolution from to lastFrame@(Frame lastStep) duration easeValToTime) frame@(Frame step)
  | frame >= lastFrame = (to, Nothing)
  | otherwise          = (interpolate from to $ assert (step >= 0) step, Just dt)
  where
    nextStep = succ step
    thisValue = fromIntegral step / fromIntegral lastStep
    targetValue = fromIntegral nextStep / fromIntegral lastStep
    dt = duration * (easeValToTime targetValue - easeValToTime thisValue)
